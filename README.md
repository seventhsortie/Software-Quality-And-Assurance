# Software Quality Assurance and Automated Testing ðŸ“ˆ
This repository showcases selected works from two comprehensive projects, namely:
- <b>Project One</b>: The `Contact` class from an application created for an unspecified client, which demonstrates my aptitude in creating unit tests using code to uncover errors, analyse various approaches to software testing based on requirements, and apply appropriate testing strategies to meet requirements.
- <b>Project Two</b>: A write-up showcasing my reflection on my work done, including my methodologies, experiences and thought process in Software Quality Assurance and Automation.
  
## Table Of Contents
- [Technologies Employed](#technologies-employed)
- [Optimal Integrity and Security](#optiomal-integrity-and-security)
- [How I Interpret User Needs](#how-i-interpret-user-needs)
- [Approaching Software Design](#approaching-software-design)
## Technologies Employed
- <b>Continuous Integration/Continuous Deployment (CI/CD)</b>: Allows for automated testing and deployment, which ensures code quality and supports frequent code changes.
- <b>JUnit Testing</b>: Utilised for unit testing, enhancing code reliability and facilitating test-driven development.

## Optimal Integrity And Security
I implementedÂ an exhaustive regimen of automated unit and integration testing using CI/CD pipelines and JUnit tests, supplemented by rigorous manual testing as needed. Security audits and industry-standard secure coding practises are incorporated into the development process to ensure that the software meets the highest operational integrity and security standards.

## How I Interpret User Needs
There are a number of ways in which I interpret user needs that translate into features and functionalities in my app. Interactions with potential end-users are my first go-to. In doing so, I establish a connection with the people that will use my app, listening for <b>pain points</b> and other concerns that they want to address by way of using my app. I then translate these needs into requirements, peridoically testing them to ensure that I'm on the right track.

## Approaching Software Design
My approach to software design is iterative and based on Test-Driven Development (TDD). First, I design and develop a suite of tests for each functionality. The next step is to write the bare minimum of code required to pass these tests. Failure of tests indicates the need for immediate code revisions. Once the code has passed all tests, I save it to version control systems like Git to keep a historical record and to facilitate collaboration. Furthermore, CI/CD pipelines are used to run tests against any code changes, ensuring a stable, functional, and secure codebase.


